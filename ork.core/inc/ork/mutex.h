///////////////////////////////////////////////////////////////////////////////
// MicroOrk (Orkid)
// Copyright 1996-2013, Michael T. Mayers
// Provided under the MIT License (see LICENSE.txt)
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <pthread.h>

namespace ork {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

class Mutex
{
public:
	//////////////////////////////////
	Mutex();
	~Mutex();
	//////////////////////////////////
	void Lock();	// recursively lock
	void Unlock();	// recursively unlock
	//////////////////////////////////	
	bool IsLocked() const { return mbLocked; }
	//////////////////////////////////
private:
	pthread_mutex_t		mMutex;
	pthread_mutexattr_t	mMutexAttr;
	bool				mbLocked;

};

///////////////////////////////////////////////////////////////////////////////

//! A locked resource is just a mutex wrapped resource which must be locked to access
//!  dont forget to unlock it when done.... (TODO: RAII based auto-unlock)

template <typename T> class LockedResource
{
public:
	//////////////////////////////////
	LockedResource()
	{
	}
	//////////////////////////////////
	~LockedResource()
	{	
		//MyAssert( false == mResourceMutex.IsLocked() );
	}	
	//////////////////////////////////
	const T& LockForRead() const
	{	mResourceMutex.Lock();
		return mResource;
	}
	//////////////////////////////////
	T& LockForWrite()
	{	mResourceMutex.Lock();
		return mResource;
	}
	//////////////////////////////////
	void UnLock() const
	{	mResourceMutex.Unlock();
	}
	//////////////////////////////////
private:
	T										mResource;
	mutable Mutex							mResourceMutex;
};

///////////////////////////////////////////////////////////////////////////////
} //namespace ork {
